run_rubias_mixture <- function(reference, mixture, gen_start_col, method = "MCMC", 
                               alle_freq_prior = list(const_scaled = 1), reps = 25000, burn_in = 5000, 
                               pb_iter = 100, sample_int_Pi = 10, pi_prior_pseudo_count_sum = 1, 
                               path = "rubias/output") {
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # This function is a wrapper for `rubias` `infer_mixture`.
  # It will return the list of 4 tibbles generated by `infer_mixture`
  # It saves three types of output for each mixture (all but "mixing_proportions")
  #
  # Inputs~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #   All inputs required for `infer_mixture` are pass on
  #   path - character vector of where to save output from each mixture as a .csv
  #
  # Outputs~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  #   Returns a dataframe in `rubias` baseline format
  #   Breaks the output into each `mixture_collection` and for each saves as .csv files for posterity:
  #     1) collection level trace, wide format (akin to .BOT file from BAYES)
  #     2) repunit level trace, wide format (akin to .RGN file from BAYES)
  #     3) straight dump of the `indiv_posteriors` tibble
  #     4) straight dump of the `bootstrapped_proportions`
  #
  # Example~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # load(".RData")
  # lynncanal_2015 <- run_rubias_mixture(reference = , mixture = , gen_start_col = 5, path = "rubias/output)
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  while(!require(rubias)){install.packages("rubias")}
  
  if(!dir.exists(path)) {stop("`path` to save output does not exist, hoser!!!")}
  
  ### Run infer mixture
  
  rubias_out <- infer_mixture(reference = reference, mixture = mixture, gen_start_col = gen_start_col, 
                              method = method, alle_freq_prior = alle_freq_prior, reps = reps, 
                              burn_in = burn_in, pb_iter = pb_iter, sample_int_Pi = sample_int_Pi, 
                              pi_prior_pseudo_count_sum = pi_prior_pseudo_count_sum)
  
  ### Save output
  message("Saving output as .csv files")
  mix_sillys = unique(mixture$collection)
  baseline_pops = unique(reference$collection)  # correctly ordered
  
  ## Save mix_prop_traces
  # Save at collection level
  message("  saving collection traces.", appendLF = FALSE)
  time_coll_trace <- system.time({
    invisible(sapply(mix_sillys, function(mixture) {
      mix_prop_trace_wide_pi <- rubias_out$mix_prop_traces %>%
        filter(mixture_collection == mixture) %>%  # filter to mixture
        mutate(collection = factor(x = collection, levels = baseline_pops)) %>%  # use factor to order collections same as baseline
        select(sweep, collection, pi) %>%  # select only sweep, collection, pi
        spread(collection, pi)  # make wide
      write_csv(x = mix_prop_trace_wide_pi, path = paste0(path, "/", mixture, "_collection_trace.csv"))
    } ))
  })
  message("   time: ", sprintf("%.2f", time_coll_trace["elapsed"]), 
          " seconds")
  
  # Save at repuinit level
  message("  saving repunit traces.", appendLF = FALSE)
  time_repunit_trace <- system.time({
    invisible(sapply(mix_sillys, function(mixture) {
      mix_prop_trace_wide_rho <- rubias_out$mix_prop_traces %>%
        filter(mixture_collection == mixture) %>%  # filter to mixture
        group_by(sweep, repunit) %>% 
        summarise(rho = sum(pi)) %>% 
        select(sweep, repunit, rho) %>%  # select only sweep, collection, pi
        spread(repunit, rho)  # make wide
      write_csv(x = mix_prop_trace_wide_rho, path = paste0(path, "/", mixture, "_repunit_trace.csv"))
    } ))
  })
  message("   time: ", sprintf("%.2f", time_repunit_trace["elapsed"]), 
          " seconds")
  
  ## Save indiv_posteriors
  message("  saving individual posteriors.", appendLF = FALSE)
  time_indiv_posteriors <- system.time({
    invisible(sapply(mix_sillys, function(mixture) {
      indiv_posteriors <- rubias_out$indiv_posteriors %>%
        filter(mixture_collection == mixture) %>% 
        select(-missing_loci)
      write_csv(x = indiv_posteriors, path = paste0(path, "/", mixture, "_indiv_posteriors.csv"))
    } ))
  })
  message("   time: ", sprintf("%.2f", time_indiv_posteriors["elapsed"]), 
          " seconds")
  
  ## Save bootstrapped_proportions
  if(method == "PB") {
    message("  saving parametric bootstrap bias corrections.", appendLF = FALSE)
    time_bias <- system.time({
      invisible(sapply(mix_sillys, function(mixture) {
        bias_corr <- rubias_out$bootstrapped_proportions %>%
          filter(mixture_collection == mixture)
        write_csv(x = bias_corr, path = paste0(path, "/", mixture, "_bias_corr.csv"))
      } ))
    })
    message("   time: ", sprintf("%.2f", time_bias["elapsed"]), 
            " seconds")
  }  # PB
  
  return(rubias_out)
}  # end function